{
  "hash": "e645d181a91edff1024029f80742cf2f",
  "result": {
    "markdown": "---\ntitle:  \"mutate_all(), select_if(), summarise_at()... what's the deal with scoped verbs?!\"\nauthor: \"Rebecca Barter\"\noutput:\n  html:\n    toc: true\ncategories: [dplyr, R, tidyverse]\ndate: 2019-01-23\ndescription: \"What's the deal with these mutate_all(), select_if(), summarise_at(), functions? They seem so useful, but there doesn't seem to be a decent explanation of how to use them anywhere on the internet. Turns out, they're called 'scoped verbs' and hopefully this post will become one of many decent explanations of how to use them!\" \n---\n\n\nNote: Scoped verbs have now essentially been superseded by `accross()` (soon to be available in dplyr 1.0.0). See [http://www.rebeccabarter.com/blog/2020-07-09-across/](http://www.rebeccabarter.com/blog/2020-07-09-across/) for details. \n\n\nI often find myself wishing that I could apply the same `mutate` function to several columns in a data frame at once, such as convert all factors to characters, or do something to all columns that have missing values, or select all variables whose names end with `_important`. When I first googled these problems around a year ago, I started to see solutions that use weird extensions of the basic `mutate()`, `select()`, `rename()`, and `summarise()` dplyr functions that look like `summarise_all()`, `filter_at()`, `mutate_if()`, and so on. I have since learned that these functions are called **\"scoped verbs\"** (where \"scoped\" means that they operate only on a selection of variables).\n\nUnfortunately, despite my extensive googling, I never really found a satisfactory description of *how* to use these functions in general, I think primarily because the documentation for these functions is not particularly useful (try `?mutate_at()`).\n\nFortunately, I recently attended a series of lightening talks hosted by the RLadies SF chapter where Sara Altman pointed us towards a [summary document](https://dcl-2017-04.github.io/curriculum/manip-scoped.html) that Hadley Wickham wrote for the Data Science class he helped create at Stanford in 2017 (this class is now taught by Sara Altman herself). \n\nTo summarise what I will demonstrate below, there are three scoped variants of the standard `mutate`, `summarise`, `rename` and `select` (and `transmute`) dplyr functions that can be specified by the following suffixes:\n\n- `_if`: allows you to pick variables that satisfy some logical criteria such as `is.numeric()` or `is.character()` (e.g. summarising only the numeric columns)\n\n- `_at`: allows you to perform an operation only on variables specified by name (e.g. mutating only the columns whose name ends with \"_date\")\n\n- `_all`: allows you to perform an operation on all variables at once (e.g. calculating the number of missing values in every column)\n\n\nTo explain how these functions all work, I will use the dataset from a survey of 800 Pittsburgh residents on whether or not they approve of self-driving car companies testing their autonomous vehicles on the streets of Pittsburgh (there have several articles on this issue in recent times in case you missed them: [1](https://www.wired.com/story/uber-returns-self-driving-after-deadly-crash/), [2](https://www.nytimes.com/2018/12/05/technology/uber-self-driving-cars.html)). The data can usually be downloaded from data.gov (but is currently unavailable due to the current Government Shutdown - I will update this with an actual link to the data one day). For now you can download the data from [here](/data/bikepghpublic.csv).\n\nA random sample of 10 rows of this dataset is shown below. To make it easy to see what's going on, I'll restrict my analysis below to these 10 rows\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# load in the only library you ever really need\nlibrary(tidyverse)\nlibrary(lubridate)\n# load in survey data\nav_survey <- read_csv(\"data/bikepghpublic.csv\")\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nset.seed(45679)\nav_survey_sample <- av_survey %>% \n  # select jsut a few columns and give some more intuitive column names\n  select(id = `Response ID`,\n         start_date = `Start Date`, \n         end_date = `End Date`,\n         interacted_with_av_as_pedestrian = InteractPedestrian,\n         interacted_with_av_as_cyclist = InteractBicycle,\n         circumstanses_of_interaction = CircumstancesCoded, # lol @ typo in data\n         approve_av_testing_pgh = FeelingsProvingGround) %>%\n  # take a random sample of 10 rows\n  sample_n(10) %>%\n  # make data frame so that we view the whole thing\n  as.data.frame()\nav_survey_sample\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n          id                 start_date                   end_date\n1  260381029  02/24/2017 3:14:19 AM PST  02/24/2017 3:18:05 AM PST\n2  260822947  03/03/2017 7:08:33 AM PST  03/03/2017 7:19:15 AM PST\n3  260907069  03/06/2017 5:57:07 PM PST  03/06/2017 5:59:08 PM PST\n4  261099035  03/08/2017 3:05:41 PM PST  03/09/2017 7:17:53 AM PST\n5  260332379  02/23/2017 9:09:11 AM PST  02/23/2017 9:11:07 AM PST\n6  260355021 02/23/2017 10:11:52 PM PST 02/23/2017 10:20:02 PM PST\n7  260350676  02/23/2017 6:10:42 PM PST  02/23/2017 6:13:59 PM PST\n8  261092370 03/08/2017 11:22:43 AM PST 03/08/2017 11:25:22 AM PST\n9  260332519  02/23/2017 9:16:14 AM PST  02/23/2017 9:21:40 AM PST\n10 260351560  02/23/2017 6:40:54 PM PST  02/23/2017 6:42:02 PM PST\n   interacted_with_av_as_pedestrian interacted_with_av_as_cyclist\n1                               Yes                           Yes\n2                                No                           Yes\n3                               Yes                           Yes\n4                                No                           Yes\n5                                No                           Yes\n6                               Yes                           Yes\n7                                No                            No\n8                          Not sure                      Not sure\n9                               Yes                            No\n10                               No                            No\n   circumstanses_of_interaction approve_av_testing_pgh\n1                             2                Approve\n2                             4             Disapprove\n3                            NA                Approve\n4                             3       Somewhat Approve\n5                            NA       Somewhat Approve\n6                             1                Approve\n7                            NA                Approve\n8                            NA    Somewhat Disapprove\n9                             2                Approve\n10                           NA    Somewhat Disapprove\n```\n:::\n:::\n\n\n\n\n# A quick useful aside: Using shorthand for functions\n\nFor many of the examples below, I will be using the `~fun(.x)` shorthand for writing temporary functions. If you've never seen this shorthand before it's incredibly useful. As an example, here are three ways of counting the number of missing values in each column of a data frame. \n\nThe first approach uses the traditional `sapply()` function and temporary function syntax. \n\n\n::: {.cell}\n\n```{.r .cell-code}\n# using apply and the normal temporary function syntax\nsapply(av_survey_sample, function(x) sum(is.na(x)))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n                              id                       start_date \n                               0                                0 \n                        end_date interacted_with_av_as_pedestrian \n                               0                                0 \n   interacted_with_av_as_cyclist     circumstanses_of_interaction \n                               0                                5 \n          approve_av_testing_pgh \n                               0 \n```\n:::\n:::\n\n\nThe second still uses the temporary function syntax, but is using the `map_dbl()` function from the `purrr` package instead of the old-school `sapply()` function.\n\n::: {.cell}\n\n```{.r .cell-code}\n# using purrr::map_dbl and the normal temporary function syntax\nav_survey_sample %>% map_dbl(function(x) sum(is.na(x)))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n                              id                       start_date \n                               0                                0 \n                        end_date interacted_with_av_as_pedestrian \n                               0                                0 \n   interacted_with_av_as_cyclist     circumstanses_of_interaction \n                               0                                5 \n          approve_av_testing_pgh \n                               0 \n```\n:::\n:::\n\n\nThe third uses the `map_dbl()` function with the `~fun(.x)` syntax.\n\n::: {.cell}\n\n```{.r .cell-code}\n# using purrr::map_dbl and the `~fun(.x)` temporary function syntax\nav_survey_sample %>% map_dbl(~sum(is.na(.x)))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n                              id                       start_date \n                               0                                0 \n                        end_date interacted_with_av_as_pedestrian \n                               0                                0 \n   interacted_with_av_as_cyclist     circumstanses_of_interaction \n                               0                                5 \n          approve_av_testing_pgh \n                               0 \n```\n:::\n:::\n\n\n\n# The _if() scoped variant: perform an operation on variables that satisfy a logical criteria\n\n`_if` allows you to perform an operation on variables that satisfy some logical criteria such as `is.numeric()` or `is.character()`.\n\n## select_if()\n\nFor instance, we can use `select_if()` to extract the numeric columns of the tibble only.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nav_survey_sample %>% select_if(is.numeric)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n          id circumstanses_of_interaction\n1  260381029                            2\n2  260822947                            4\n3  260907069                           NA\n4  261099035                            3\n5  260332379                           NA\n6  260355021                            1\n7  260350676                           NA\n8  261092370                           NA\n9  260332519                            2\n10 260351560                           NA\n```\n:::\n:::\n\n\nWe could also apply use more complex logical statements, for example by selecting columns that have at least one missing value. \n\n\n::: {.cell}\n\n```{.r .cell-code}\nav_survey_sample %>% \n  # select columns with at least one NA\n  # the expression evaluates to TRUE if there is one or more missing values\n  select_if(~sum(is.na(.x)) > 0) \n```\n\n::: {.cell-output .cell-output-stdout}\n```\n   circumstanses_of_interaction\n1                             2\n2                             4\n3                            NA\n4                             3\n5                            NA\n6                             1\n7                            NA\n8                            NA\n9                             2\n10                           NA\n```\n:::\n:::\n\n\n## rename_if()\n\nWe could rename columns that satisfy a logical expression using `rename_if()`. For instance, we can add a `num_` prefix to all numeric column names.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nav_survey_sample %>%\n  # only rename numeric columns by adding a \"num_\" prefix\n  rename_if(is.numeric, ~paste0(\"num_\", .x))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n      num_id                 start_date                   end_date\n1  260381029  02/24/2017 3:14:19 AM PST  02/24/2017 3:18:05 AM PST\n2  260822947  03/03/2017 7:08:33 AM PST  03/03/2017 7:19:15 AM PST\n3  260907069  03/06/2017 5:57:07 PM PST  03/06/2017 5:59:08 PM PST\n4  261099035  03/08/2017 3:05:41 PM PST  03/09/2017 7:17:53 AM PST\n5  260332379  02/23/2017 9:09:11 AM PST  02/23/2017 9:11:07 AM PST\n6  260355021 02/23/2017 10:11:52 PM PST 02/23/2017 10:20:02 PM PST\n7  260350676  02/23/2017 6:10:42 PM PST  02/23/2017 6:13:59 PM PST\n8  261092370 03/08/2017 11:22:43 AM PST 03/08/2017 11:25:22 AM PST\n9  260332519  02/23/2017 9:16:14 AM PST  02/23/2017 9:21:40 AM PST\n10 260351560  02/23/2017 6:40:54 PM PST  02/23/2017 6:42:02 PM PST\n   interacted_with_av_as_pedestrian interacted_with_av_as_cyclist\n1                               Yes                           Yes\n2                                No                           Yes\n3                               Yes                           Yes\n4                                No                           Yes\n5                                No                           Yes\n6                               Yes                           Yes\n7                                No                            No\n8                          Not sure                      Not sure\n9                               Yes                            No\n10                               No                            No\n   num_circumstanses_of_interaction approve_av_testing_pgh\n1                                 2                Approve\n2                                 4             Disapprove\n3                                NA                Approve\n4                                 3       Somewhat Approve\n5                                NA       Somewhat Approve\n6                                 1                Approve\n7                                NA                Approve\n8                                NA    Somewhat Disapprove\n9                                 2                Approve\n10                               NA    Somewhat Disapprove\n```\n:::\n:::\n\n\n## mutate_if()\n\nWe could similarly use `mutate_if()` to mutate columns that satisfy specified logical conditions. In the example below, we mutate all columns that have at least one missing value by replacing `NA` with `\"missing\"`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nav_survey_sample %>% \n  # only mutate columns with at least one NA\n  # replace each NA value with the character \"missing\"\n  mutate_if(~sum(is.na(.x)) > 0,\n            ~if_else(is.na(.x), \"missing\", as.character(.x)))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n          id                 start_date                   end_date\n1  260381029  02/24/2017 3:14:19 AM PST  02/24/2017 3:18:05 AM PST\n2  260822947  03/03/2017 7:08:33 AM PST  03/03/2017 7:19:15 AM PST\n3  260907069  03/06/2017 5:57:07 PM PST  03/06/2017 5:59:08 PM PST\n4  261099035  03/08/2017 3:05:41 PM PST  03/09/2017 7:17:53 AM PST\n5  260332379  02/23/2017 9:09:11 AM PST  02/23/2017 9:11:07 AM PST\n6  260355021 02/23/2017 10:11:52 PM PST 02/23/2017 10:20:02 PM PST\n7  260350676  02/23/2017 6:10:42 PM PST  02/23/2017 6:13:59 PM PST\n8  261092370 03/08/2017 11:22:43 AM PST 03/08/2017 11:25:22 AM PST\n9  260332519  02/23/2017 9:16:14 AM PST  02/23/2017 9:21:40 AM PST\n10 260351560  02/23/2017 6:40:54 PM PST  02/23/2017 6:42:02 PM PST\n   interacted_with_av_as_pedestrian interacted_with_av_as_cyclist\n1                               Yes                           Yes\n2                                No                           Yes\n3                               Yes                           Yes\n4                                No                           Yes\n5                                No                           Yes\n6                               Yes                           Yes\n7                                No                            No\n8                          Not sure                      Not sure\n9                               Yes                            No\n10                               No                            No\n   circumstanses_of_interaction approve_av_testing_pgh\n1                             2                Approve\n2                             4             Disapprove\n3                       missing                Approve\n4                             3       Somewhat Approve\n5                       missing       Somewhat Approve\n6                             1                Approve\n7                       missing                Approve\n8                       missing    Somewhat Disapprove\n9                             2                Approve\n10                      missing    Somewhat Disapprove\n```\n:::\n:::\n\n\n## summarise_if()\n\nSimilarly, `summarise_if()` will summarise columns that satisfy the specified logical conditions. Below, we summarise each character column by reporting the most common value (but for some reason there is no `mode()` function in R, so we need to write our own).\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# function to calculate the mode (most common) observation\nmode <- function(x) {\n  names(sort(table(x)))[1]\n}\n# summarise character\nav_survey_sample %>% \n  summarise_if(is.character, mode)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n                  start_date                   end_date\n1 02/23/2017 10:11:52 PM PST 02/23/2017 10:20:02 PM PST\n  interacted_with_av_as_pedestrian interacted_with_av_as_cyclist\n1                         Not sure                      Not sure\n  approve_av_testing_pgh\n1             Disapprove\n```\n:::\n:::\n\n\n\n\n# The _at() scoped variant: perform an operation only on variables specified by name\n\n`_at` allows you to perform an operation only on variables specified by name.\n\nTo specify which variables you want to operate on, you need to include the variable names inside the `vars()` function as the first argument. I think of as like `vars()` like `c()` to provide multiple values (in this case variable names) as a single argument. For example `av_survey_sample %>% mutate_at(vars(start_date, end_date), mdy_hms)` will only mutate the `start_date` and `end_date` variables by converting them to lubridate format using the `mdy_hms` function.\n\nThese variables can be specified explicitly by name within the `vars()` function, or using the **select_helpers** within the `vars()` function.\n\n## Select helpers\n\nSelect helpers are functions that you can use within `select()` to help specify which variables you want to select. The options are\n\n- `starts_with()`: select all variables that start with a specified character string\n\n- `ends_with()`: select all variables that end with a specified character string\n\n- `contains()`: select all variables that contain a specified character string\n\n- `matches()`: select variables that match a specified character string\n\n- `one_of()`: selects variables that match any entries in the specified character vector\n\n- `num_range()`: selects variables that are numbered (e.g. columns named `V1`, `V2`, `V3` would be selected by `select(num_range(\"V\", 1:3))`)\n\nThere are many ways that we could select the `date` variables using the `ends_with()` and `contains()` select helpers:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# selecting the date columns by providing their names\nav_survey_sample %>% select(start_date, end_date)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n                   start_date                   end_date\n1   02/24/2017 3:14:19 AM PST  02/24/2017 3:18:05 AM PST\n2   03/03/2017 7:08:33 AM PST  03/03/2017 7:19:15 AM PST\n3   03/06/2017 5:57:07 PM PST  03/06/2017 5:59:08 PM PST\n4   03/08/2017 3:05:41 PM PST  03/09/2017 7:17:53 AM PST\n5   02/23/2017 9:09:11 AM PST  02/23/2017 9:11:07 AM PST\n6  02/23/2017 10:11:52 PM PST 02/23/2017 10:20:02 PM PST\n7   02/23/2017 6:10:42 PM PST  02/23/2017 6:13:59 PM PST\n8  03/08/2017 11:22:43 AM PST 03/08/2017 11:25:22 AM PST\n9   02/23/2017 9:16:14 AM PST  02/23/2017 9:21:40 AM PST\n10  02/23/2017 6:40:54 PM PST  02/23/2017 6:42:02 PM PST\n```\n:::\n\n```{.r .cell-code}\n# selecting the columns that end with \"_date\"\nav_survey_sample %>% select(ends_with(\"_date\"))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n                   start_date                   end_date\n1   02/24/2017 3:14:19 AM PST  02/24/2017 3:18:05 AM PST\n2   03/03/2017 7:08:33 AM PST  03/03/2017 7:19:15 AM PST\n3   03/06/2017 5:57:07 PM PST  03/06/2017 5:59:08 PM PST\n4   03/08/2017 3:05:41 PM PST  03/09/2017 7:17:53 AM PST\n5   02/23/2017 9:09:11 AM PST  02/23/2017 9:11:07 AM PST\n6  02/23/2017 10:11:52 PM PST 02/23/2017 10:20:02 PM PST\n7   02/23/2017 6:10:42 PM PST  02/23/2017 6:13:59 PM PST\n8  03/08/2017 11:22:43 AM PST 03/08/2017 11:25:22 AM PST\n9   02/23/2017 9:16:14 AM PST  02/23/2017 9:21:40 AM PST\n10  02/23/2017 6:40:54 PM PST  02/23/2017 6:42:02 PM PST\n```\n:::\n\n```{.r .cell-code}\n# selecting the columns that contain \"date\"\nav_survey_sample %>% select(contains(\"date\"))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n                   start_date                   end_date\n1   02/24/2017 3:14:19 AM PST  02/24/2017 3:18:05 AM PST\n2   03/03/2017 7:08:33 AM PST  03/03/2017 7:19:15 AM PST\n3   03/06/2017 5:57:07 PM PST  03/06/2017 5:59:08 PM PST\n4   03/08/2017 3:05:41 PM PST  03/09/2017 7:17:53 AM PST\n5   02/23/2017 9:09:11 AM PST  02/23/2017 9:11:07 AM PST\n6  02/23/2017 10:11:52 PM PST 02/23/2017 10:20:02 PM PST\n7   02/23/2017 6:10:42 PM PST  02/23/2017 6:13:59 PM PST\n8  03/08/2017 11:22:43 AM PST 03/08/2017 11:25:22 AM PST\n9   02/23/2017 9:16:14 AM PST  02/23/2017 9:21:40 AM PST\n10  02/23/2017 6:40:54 PM PST  02/23/2017 6:42:02 PM PST\n```\n:::\n:::\n\n\nIf you ever find yourself wanting to provide variable names as characters, the `matches()` and `one_of()` select helpers can help you do that.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# provide matches with a single character variables\nvariable <- \"start_date\"\nav_survey_sample %>% select(matches(variable))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n                   start_date\n1   02/24/2017 3:14:19 AM PST\n2   03/03/2017 7:08:33 AM PST\n3   03/06/2017 5:57:07 PM PST\n4   03/08/2017 3:05:41 PM PST\n5   02/23/2017 9:09:11 AM PST\n6  02/23/2017 10:11:52 PM PST\n7   02/23/2017 6:10:42 PM PST\n8  03/08/2017 11:22:43 AM PST\n9   02/23/2017 9:16:14 AM PST\n10  02/23/2017 6:40:54 PM PST\n```\n:::\n\n```{.r .cell-code}\n# provide one_of with a vector of character variables\nvariables <- c(\"start_date\", \"end_date\")\nav_survey_sample %>% select(one_of(variables))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n                   start_date                   end_date\n1   02/24/2017 3:14:19 AM PST  02/24/2017 3:18:05 AM PST\n2   03/03/2017 7:08:33 AM PST  03/03/2017 7:19:15 AM PST\n3   03/06/2017 5:57:07 PM PST  03/06/2017 5:59:08 PM PST\n4   03/08/2017 3:05:41 PM PST  03/09/2017 7:17:53 AM PST\n5   02/23/2017 9:09:11 AM PST  02/23/2017 9:11:07 AM PST\n6  02/23/2017 10:11:52 PM PST 02/23/2017 10:20:02 PM PST\n7   02/23/2017 6:10:42 PM PST  02/23/2017 6:13:59 PM PST\n8  03/08/2017 11:22:43 AM PST 03/08/2017 11:25:22 AM PST\n9   02/23/2017 9:16:14 AM PST  02/23/2017 9:21:40 AM PST\n10  02/23/2017 6:40:54 PM PST  02/23/2017 6:42:02 PM PST\n```\n:::\n:::\n\n\nNote that technically there does exist a `select_at()` function that requires a `vars()` input, but I can't really think of a good use of this function...\n\n::: {.cell}\n\n```{.r .cell-code}\n# this is the same as av_survey_sample %>% select(start_date, end_date)\nav_survey_sample %>% \n  select_at(vars(start_date, end_date))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n                   start_date                   end_date\n1   02/24/2017 3:14:19 AM PST  02/24/2017 3:18:05 AM PST\n2   03/03/2017 7:08:33 AM PST  03/03/2017 7:19:15 AM PST\n3   03/06/2017 5:57:07 PM PST  03/06/2017 5:59:08 PM PST\n4   03/08/2017 3:05:41 PM PST  03/09/2017 7:17:53 AM PST\n5   02/23/2017 9:09:11 AM PST  02/23/2017 9:11:07 AM PST\n6  02/23/2017 10:11:52 PM PST 02/23/2017 10:20:02 PM PST\n7   02/23/2017 6:10:42 PM PST  02/23/2017 6:13:59 PM PST\n8  03/08/2017 11:22:43 AM PST 03/08/2017 11:25:22 AM PST\n9   02/23/2017 9:16:14 AM PST  02/23/2017 9:21:40 AM PST\n10  02/23/2017 6:40:54 PM PST  02/23/2017 6:42:02 PM PST\n```\n:::\n:::\n\n\nThe syntax of this `select_at()` example though can be useful for understanding how the `vars()` function can be used in the other `_at()` functions).\n\n## rename_at()\n\nYou can rename specified variables using the `rename_at()` function. For instance, we could replace all column names that contain the character string \"av\" with the same column name but an uppercase \"AV\" instead of the original lowercase \"av\".\n\nTo do this, we use the select helper `contains()` within the `vars()` function.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# use a select helper to only apply to columns whose name contains \"av\"\n# then rename these columns with \"AV\" in place of \"av\"\nav_survey_sample %>% \n  rename_at(vars(contains(\"av\")), \n            ~gsub(\"av\", \"AV\", .x))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n          id                 start_date                   end_date\n1  260381029  02/24/2017 3:14:19 AM PST  02/24/2017 3:18:05 AM PST\n2  260822947  03/03/2017 7:08:33 AM PST  03/03/2017 7:19:15 AM PST\n3  260907069  03/06/2017 5:57:07 PM PST  03/06/2017 5:59:08 PM PST\n4  261099035  03/08/2017 3:05:41 PM PST  03/09/2017 7:17:53 AM PST\n5  260332379  02/23/2017 9:09:11 AM PST  02/23/2017 9:11:07 AM PST\n6  260355021 02/23/2017 10:11:52 PM PST 02/23/2017 10:20:02 PM PST\n7  260350676  02/23/2017 6:10:42 PM PST  02/23/2017 6:13:59 PM PST\n8  261092370 03/08/2017 11:22:43 AM PST 03/08/2017 11:25:22 AM PST\n9  260332519  02/23/2017 9:16:14 AM PST  02/23/2017 9:21:40 AM PST\n10 260351560  02/23/2017 6:40:54 PM PST  02/23/2017 6:42:02 PM PST\n   interacted_with_AV_as_pedestrian interacted_with_AV_as_cyclist\n1                               Yes                           Yes\n2                                No                           Yes\n3                               Yes                           Yes\n4                                No                           Yes\n5                                No                           Yes\n6                               Yes                           Yes\n7                                No                            No\n8                          Not sure                      Not sure\n9                               Yes                            No\n10                               No                            No\n   circumstanses_of_interaction approve_AV_testing_pgh\n1                             2                Approve\n2                             4             Disapprove\n3                            NA                Approve\n4                             3       Somewhat Approve\n5                            NA       Somewhat Approve\n6                             1                Approve\n7                            NA                Approve\n8                            NA    Somewhat Disapprove\n9                             2                Approve\n10                           NA    Somewhat Disapprove\n```\n:::\n:::\n\n\n\n## mutate_at()\n\nTo mutate only the date variables, normally we would do the `mdy_hms()` transformation to each variable separately as follows:\n\n::: {.cell}\n\n```{.r .cell-code}\n# use the standard (unscoped) approach\nav_survey_sample %>% \n  mutate(start_date = mdy_hms(start_date),\n         end_date = mdy_hms(end_date))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n          id          start_date            end_date\n1  260381029 2017-02-24 03:14:19 2017-02-24 03:18:05\n2  260822947 2017-03-03 07:08:33 2017-03-03 07:19:15\n3  260907069 2017-03-06 17:57:07 2017-03-06 17:59:08\n4  261099035 2017-03-08 15:05:41 2017-03-09 07:17:53\n5  260332379 2017-02-23 09:09:11 2017-02-23 09:11:07\n6  260355021 2017-02-23 22:11:52 2017-02-23 22:20:02\n7  260350676 2017-02-23 18:10:42 2017-02-23 18:13:59\n8  261092370 2017-03-08 11:22:43 2017-03-08 11:25:22\n9  260332519 2017-02-23 09:16:14 2017-02-23 09:21:40\n10 260351560 2017-02-23 18:40:54 2017-02-23 18:42:02\n   interacted_with_av_as_pedestrian interacted_with_av_as_cyclist\n1                               Yes                           Yes\n2                                No                           Yes\n3                               Yes                           Yes\n4                                No                           Yes\n5                                No                           Yes\n6                               Yes                           Yes\n7                                No                            No\n8                          Not sure                      Not sure\n9                               Yes                            No\n10                               No                            No\n   circumstanses_of_interaction approve_av_testing_pgh\n1                             2                Approve\n2                             4             Disapprove\n3                            NA                Approve\n4                             3       Somewhat Approve\n5                            NA       Somewhat Approve\n6                             1                Approve\n7                            NA                Approve\n8                            NA    Somewhat Disapprove\n9                             2                Approve\n10                           NA    Somewhat Disapprove\n```\n:::\n:::\n\n\nHowever, using `mutate_at()` and supplying these column names as arguments to the `vars()` function, we could specify the function only once. \n\n::: {.cell}\n\n```{.r .cell-code}\n# specifying specific variables to apply the same function to\nav_survey_sample %>% \n  mutate_at(vars(start_date, end_date), mdy_hms)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n          id          start_date            end_date\n1  260381029 2017-02-24 03:14:19 2017-02-24 03:18:05\n2  260822947 2017-03-03 07:08:33 2017-03-03 07:19:15\n3  260907069 2017-03-06 17:57:07 2017-03-06 17:59:08\n4  261099035 2017-03-08 15:05:41 2017-03-09 07:17:53\n5  260332379 2017-02-23 09:09:11 2017-02-23 09:11:07\n6  260355021 2017-02-23 22:11:52 2017-02-23 22:20:02\n7  260350676 2017-02-23 18:10:42 2017-02-23 18:13:59\n8  261092370 2017-03-08 11:22:43 2017-03-08 11:25:22\n9  260332519 2017-02-23 09:16:14 2017-02-23 09:21:40\n10 260351560 2017-02-23 18:40:54 2017-02-23 18:42:02\n   interacted_with_av_as_pedestrian interacted_with_av_as_cyclist\n1                               Yes                           Yes\n2                                No                           Yes\n3                               Yes                           Yes\n4                                No                           Yes\n5                                No                           Yes\n6                               Yes                           Yes\n7                                No                            No\n8                          Not sure                      Not sure\n9                               Yes                            No\n10                               No                            No\n   circumstanses_of_interaction approve_av_testing_pgh\n1                             2                Approve\n2                             4             Disapprove\n3                            NA                Approve\n4                             3       Somewhat Approve\n5                            NA       Somewhat Approve\n6                             1                Approve\n7                            NA                Approve\n8                            NA    Somewhat Disapprove\n9                             2                Approve\n10                           NA    Somewhat Disapprove\n```\n:::\n:::\n\n\nMoreover, we can use the select helpers to specify which columns we want to mutate, without having to write out the entire column names.\n\n::: {.cell}\n\n```{.r .cell-code}\n# use a \"select helper\" to specify the variables that end with \"_date\"\nav_survey_sample %>% \n  mutate_at(vars(ends_with(\"_date\")), mdy_hms)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n          id          start_date            end_date\n1  260381029 2017-02-24 03:14:19 2017-02-24 03:18:05\n2  260822947 2017-03-03 07:08:33 2017-03-03 07:19:15\n3  260907069 2017-03-06 17:57:07 2017-03-06 17:59:08\n4  261099035 2017-03-08 15:05:41 2017-03-09 07:17:53\n5  260332379 2017-02-23 09:09:11 2017-02-23 09:11:07\n6  260355021 2017-02-23 22:11:52 2017-02-23 22:20:02\n7  260350676 2017-02-23 18:10:42 2017-02-23 18:13:59\n8  261092370 2017-03-08 11:22:43 2017-03-08 11:25:22\n9  260332519 2017-02-23 09:16:14 2017-02-23 09:21:40\n10 260351560 2017-02-23 18:40:54 2017-02-23 18:42:02\n   interacted_with_av_as_pedestrian interacted_with_av_as_cyclist\n1                               Yes                           Yes\n2                                No                           Yes\n3                               Yes                           Yes\n4                                No                           Yes\n5                                No                           Yes\n6                               Yes                           Yes\n7                                No                            No\n8                          Not sure                      Not sure\n9                               Yes                            No\n10                               No                            No\n   circumstanses_of_interaction approve_av_testing_pgh\n1                             2                Approve\n2                             4             Disapprove\n3                            NA                Approve\n4                             3       Somewhat Approve\n5                            NA       Somewhat Approve\n6                             1                Approve\n7                            NA                Approve\n8                            NA    Somewhat Disapprove\n9                             2                Approve\n10                           NA    Somewhat Disapprove\n```\n:::\n:::\n\n\n\n## summarise_at()\n\nThe `summarise_at()` scoped verb behaves very similarly to the `mutate_at()` scoped verb, in that we can easily specify *which* variables we want to apply the same summary function to.\n\nFor instance, the following example summarises all variables that contain the word \"interacted\" by counting the number of \"Yes\" entries.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nav_survey_sample %>% \n  summarise_at(vars(contains(\"interacted\")), ~sum(.x == \"Yes\"))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n  interacted_with_av_as_pedestrian interacted_with_av_as_cyclist\n1                                4                             6\n```\n:::\n:::\n\n\n\n# The _all() scoped variant: perform an operation on all variables at once\n\n`_all` allows you to perform an operation on all variables at once (e.g. calculating the number of missing values in every column).\n\n## rename_all()\n\nThe `select_all()` would is quite redundant (it would simply return all columns). Its friend `rename_all()`, however can be very useful. \n\nFor instance, we could rename all variables by replacing underscores `_` with dots `.` (although I would advise against this: underscores are way better than dots!).\n\n\n::: {.cell}\n\n```{.r .cell-code}\nav_survey_sample %>% \n  rename_all(~gsub(\"_\", \".\", .x))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n          id                 start.date                   end.date\n1  260381029  02/24/2017 3:14:19 AM PST  02/24/2017 3:18:05 AM PST\n2  260822947  03/03/2017 7:08:33 AM PST  03/03/2017 7:19:15 AM PST\n3  260907069  03/06/2017 5:57:07 PM PST  03/06/2017 5:59:08 PM PST\n4  261099035  03/08/2017 3:05:41 PM PST  03/09/2017 7:17:53 AM PST\n5  260332379  02/23/2017 9:09:11 AM PST  02/23/2017 9:11:07 AM PST\n6  260355021 02/23/2017 10:11:52 PM PST 02/23/2017 10:20:02 PM PST\n7  260350676  02/23/2017 6:10:42 PM PST  02/23/2017 6:13:59 PM PST\n8  261092370 03/08/2017 11:22:43 AM PST 03/08/2017 11:25:22 AM PST\n9  260332519  02/23/2017 9:16:14 AM PST  02/23/2017 9:21:40 AM PST\n10 260351560  02/23/2017 6:40:54 PM PST  02/23/2017 6:42:02 PM PST\n   interacted.with.av.as.pedestrian interacted.with.av.as.cyclist\n1                               Yes                           Yes\n2                                No                           Yes\n3                               Yes                           Yes\n4                                No                           Yes\n5                                No                           Yes\n6                               Yes                           Yes\n7                                No                            No\n8                          Not sure                      Not sure\n9                               Yes                            No\n10                               No                            No\n   circumstanses.of.interaction approve.av.testing.pgh\n1                             2                Approve\n2                             4             Disapprove\n3                            NA                Approve\n4                             3       Somewhat Approve\n5                            NA       Somewhat Approve\n6                             1                Approve\n7                            NA                Approve\n8                            NA    Somewhat Disapprove\n9                             2                Approve\n10                           NA    Somewhat Disapprove\n```\n:::\n:::\n\n\n## mutate_all()\n\nWe could apply the same mutate function to every column at once using `mutate_all()`. For instance, the code below converts every column to a numeric (although this results in mostly missing values for the character variables)\n\n\n::: {.cell}\n\n```{.r .cell-code}\nav_survey_sample %>%\n  mutate_all(as.numeric)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n          id start_date end_date interacted_with_av_as_pedestrian\n1  260381029         NA       NA                               NA\n2  260822947         NA       NA                               NA\n3  260907069         NA       NA                               NA\n4  261099035         NA       NA                               NA\n5  260332379         NA       NA                               NA\n6  260355021         NA       NA                               NA\n7  260350676         NA       NA                               NA\n8  261092370         NA       NA                               NA\n9  260332519         NA       NA                               NA\n10 260351560         NA       NA                               NA\n   interacted_with_av_as_cyclist circumstanses_of_interaction\n1                             NA                            2\n2                             NA                            4\n3                             NA                           NA\n4                             NA                            3\n5                             NA                           NA\n6                             NA                            1\n7                             NA                           NA\n8                             NA                           NA\n9                             NA                            2\n10                            NA                           NA\n   approve_av_testing_pgh\n1                      NA\n2                      NA\n3                      NA\n4                      NA\n5                      NA\n6                      NA\n7                      NA\n8                      NA\n9                      NA\n10                     NA\n```\n:::\n:::\n\n\n\n## summarise_all()\n\nWe could also apply the same summary function to every column at once using `summarise_all()`. For instance, the example below calculates the number of distinct entries in each column.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nav_survey_sample %>%\n  summarise_all(n_distinct)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n  id start_date end_date interacted_with_av_as_pedestrian\n1 10         10       10                                3\n  interacted_with_av_as_cyclist circumstanses_of_interaction\n1                             3                            5\n  approve_av_testing_pgh\n1                      4\n```\n:::\n:::\n\n\n\n# Conclusion\n\nHopefully this summary is useful to you in your data manipulation adventures! \n\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}