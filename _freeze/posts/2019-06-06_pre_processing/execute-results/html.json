{
  "hash": "816528539aaa82836e3b08dd7d59f6c3",
  "result": {
    "markdown": "---\ntitle: \"Using the recipes package for easy pre-processing\"\nauthor: \"Rebecca Barter\"\noutput:\n  html:\n    toc: true\ncategories: [R, workflow, machine learning]\ndate: 2019-06-06\ndescription: \"Having to apply the same pre-processing steps to training, testing and validation data to do some machine learning can be surprisingly frustrating. But thanks to the recipes R package, it's now super-duper easy. Instead of having five functions and maybe hundreds of lines of code, you can preprocess multiple datasets using a single 'recipe' in fewer than 10 lines of code.\" \n---\n\n\nPre-processing data in R used to be the bane of my existence. For something that should be fairly straightforward, it often really wasn't. Often my frustrations stemmed from simple things such as factor variables having different levels in the training data and test data, or a variable having missing values in the test data but not in the training data. I'd write a function that would pre-process the training data, and when I'd try to apply it to the test data, R would cry and yell and just be generally unpleasant.\n\nThankfully most of the pain of pre-processing is now in the past thanks to the [recipes](https://tidymodels.github.io/recipes/) R package that is a part of the new \"tidymodels\" package ecosystem (which, I guess is supposed to be equivalent to the data-focused \"tidyverse\" package ecosystem that includes dplyr, tidyr, and other super awesome packages like that). Recipes was developed by Max Kuhn and Hadley Wickham.\n\n<!-- Those who have ever seen Hadley Wickham give a talk will know that baking and data are inherently related (see photo below).  -->\n\n<!-- ```{r echo = FALSE, fig.align=\"center\", fig.cap = \"A photo I took at an R Ladies SF meetup of Hadley's cupcake recipes.\"} -->\n\n<!-- knitr::include_graphics(\"/img/recipes/hadley_cupcakes.jpg\") -->\n\n<!-- ``` -->\n\nSo let's get baking!\n\n## The fundamentals of pre-processing your data using recipes\n\nCreating a recipe has four steps:\n\n1.  **Get the ingredients** (`recipe()`): specify the response variable and predictor variables\n\n2.  **Write the recipe** (`step_zzz()`): define the pre-processing steps, such as imputation, creating dummy variables, scaling, and more\n\n3.  **Prepare the recipe** (`prep()`): provide a dataset to base each step on (e.g. if one of the steps is to remove variables that only have one unique value, then you need to give it a dataset so it can decide which variables satisfy this criteria to ensure that it is doing the same thing to every dataset you apply it to)\n\n4.  **Bake the recipe** (`bake()`): apply the pre-processing steps to your datasets\n\nIn this blog post I'll walk you through these three steps, touching on the wide range of things that recipes can do, while hopefully convincing you that recipes makes life really easy and that you should use it next time you need to do some pre-processing.\n\n## A simple example: cupcakes or muffins?\n\nTo keep things in the theme, I'm going to use a dataset from [Alice Zhao's git repo](https://github.com/adashofdata) that I found when I typed \"cupcake dataset\" into Google. Our goal will be to classify recipes as either cupcakes or muffins based on the quantities used for each of the ingredients. So perhaps we will learn two things today: (1) how to use the recipes package, and (2) the difference between cupcakes and muffins.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# set up so that all variables of tibbles are printed\noptions(dplyr.width = Inf)\n# load useful libraries\nlibrary(tidyverse)\nlibrary(recipes) # could also load the tidymodels package\n# load in the data\nmuffin_cupcake_data_orig <- read_csv(\"https://raw.githubusercontent.com/adashofdata/muffin-cupcake/master/recipes_muffins_cupcakes.csv\")\n# look at data\nmuffin_cupcake_data_orig\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 20 × 9\n   Type    Flour  Milk Sugar Butter   Egg `Baking Powder` Vanilla  Salt\n   <chr>   <dbl> <dbl> <dbl>  <dbl> <dbl>           <dbl>   <dbl> <dbl>\n 1 Muffin     55    28     3      7     5               2       0     0\n 2 Muffin     47    24    12      6     9               1       0     0\n 3 Muffin     47    23    18      6     4               1       0     0\n 4 Muffin     45    11    17     17     8               1       0     0\n 5 Muffin     50    25    12      6     5               2       1     0\n 6 Muffin     55    27     3      7     5               2       1     0\n 7 Muffin     54    27     7      5     5               2       0     0\n 8 Muffin     47    26    10     10     4               1       0     0\n 9 Muffin     50    17    17      8     6               1       0     0\n10 Muffin     50    17    17     11     4               1       0     0\n11 Cupcake    39     0    26     19    14               1       1     0\n12 Cupcake    42    21    16     10     8               3       0     0\n13 Cupcake    34    17    20     20     5               2       1     0\n14 Cupcake    39    13    17     19    10               1       1     0\n15 Cupcake    38    15    23     15     8               0       1     0\n16 Cupcake    42    18    25      9     5               1       0     0\n17 Cupcake    36    14    21     14    11               2       1     0\n18 Cupcake    38    15    31      8     6               1       1     0\n19 Cupcake    36    16    24     12     9               1       1     0\n20 Cupcake    34    17    23     11    13               0       1     0\n```\n:::\n:::\n\n\nSince the space in the column name `Baking Powder` is going to really annoy me, I'm going to do a quick clean where I convert all of the column names to lower case and replace the space with an underscore.\n\nAs a side note, I've started naming all of my temporary function arguments (lambda functions?) with a period preceding the name. I find it makes it a lot easier to read. As another side note, if you've never seen the `rename_all()` function before, check out my [blog post](http://www.rebeccabarter.com/blog/2019-01-23_scoped-verbs/) on scoped verbs!\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmuffin_cupcake_data <- muffin_cupcake_data_orig %>%\n  # rename all columns \n  rename_all(function(.name) {\n    .name %>% \n      # replace all names with the lowercase versions\n      tolower %>%\n      # replace all spaces with underscores\n      str_replace(\" \", \"_\")\n    })\n# check that this did what I wanted\nmuffin_cupcake_data\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 20 × 9\n   type    flour  milk sugar butter   egg baking_powder vanilla  salt\n   <chr>   <dbl> <dbl> <dbl>  <dbl> <dbl>         <dbl>   <dbl> <dbl>\n 1 Muffin     55    28     3      7     5             2       0     0\n 2 Muffin     47    24    12      6     9             1       0     0\n 3 Muffin     47    23    18      6     4             1       0     0\n 4 Muffin     45    11    17     17     8             1       0     0\n 5 Muffin     50    25    12      6     5             2       1     0\n 6 Muffin     55    27     3      7     5             2       1     0\n 7 Muffin     54    27     7      5     5             2       0     0\n 8 Muffin     47    26    10     10     4             1       0     0\n 9 Muffin     50    17    17      8     6             1       0     0\n10 Muffin     50    17    17     11     4             1       0     0\n11 Cupcake    39     0    26     19    14             1       1     0\n12 Cupcake    42    21    16     10     8             3       0     0\n13 Cupcake    34    17    20     20     5             2       1     0\n14 Cupcake    39    13    17     19    10             1       1     0\n15 Cupcake    38    15    23     15     8             0       1     0\n16 Cupcake    42    18    25      9     5             1       0     0\n17 Cupcake    36    14    21     14    11             2       1     0\n18 Cupcake    38    15    31      8     6             1       1     0\n19 Cupcake    36    16    24     12     9             1       1     0\n20 Cupcake    34    17    23     11    13             0       1     0\n```\n:::\n:::\n\n\nSince recipes does a lot of useful stuff for categorical variables as well as with missing values, I'm going to modify the data a little bit so that it's a bit more interesting (for educational purposes only - don't ever actually modify your data so it's more interesting, in science that's called \"fraud\", and fraud is bad).\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# add an additional ingredients column that is categorical\nmuffin_cupcake_data <- muffin_cupcake_data %>%\n  mutate(additional_ingredients = c(\"fruit\", \n                                    \"fruit\", \n                                    \"none\", \n                                    \"nuts\", \n                                    \"fruit\", \n                                    \"fruit\", \n                                    \"nuts\", \n                                    \"none\", \n                                    \"none\", \n                                    \"nuts\",\n                                    \"icing\",\n                                    \"icing\",\n                                    \"fruit\",\n                                    \"none\",\n                                    \"fruit\",\n                                    \"icing\",\n                                    \"none\",\n                                    \"fruit\",\n                                    \"icing\",\n                                    \"icing\"))\n# add some random missing values here and there just for fun\nset.seed(26738)\nmuffin_cupcake_data <- muffin_cupcake_data %>%\n  # only add missing values to numeric columns\n  mutate_if(is.numeric,\n            function(x) {\n              # randomly decide if 0, 2, or 3 values will be missing from each column\n              n_missing <- sample(0:3, 1)\n              # replace n_missing randomly selected values from each column with NA\n              x[sample(1:20, n_missing)] <- NA\n              return(x)\n              })\nmuffin_cupcake_data\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 20 × 10\n   type    flour  milk sugar butter   egg baking_powder vanilla  salt\n   <chr>   <dbl> <dbl> <dbl>  <dbl> <dbl>         <dbl>   <dbl> <dbl>\n 1 Muffin     55    28     3      7     5             2       0     0\n 2 Muffin     47    24    12      6     9             1      NA     0\n 3 Muffin     47    23    18      6     4             1       0     0\n 4 Muffin     NA    NA    17     17     8            NA       0     0\n 5 Muffin     50    25    12      6     5             2       1     0\n 6 Muffin     55    27     3      7     5             2       1     0\n 7 Muffin     54    27     7      5     5             2       0     0\n 8 Muffin     47    26    10     10     4            NA      NA     0\n 9 Muffin     50    17    17      8     6             1       0     0\n10 Muffin     50    NA    17     11     4             1       0     0\n11 Cupcake    39     0    26     19    14             1       1     0\n12 Cupcake    42    21    16     10     8             3       0     0\n13 Cupcake    NA    17    20     20     5             2       1     0\n14 Cupcake    39    13    17     19    10             1       1     0\n15 Cupcake    38    15    23     NA     8             0       1     0\n16 Cupcake    42    18    25     NA     5             1       0     0\n17 Cupcake    36    14    21     14    11             2       1     0\n18 Cupcake    38    15    31      8     6             1       1     0\n19 Cupcake    36    16    24     12     9             1      NA     0\n20 Cupcake    34    17    23     11    13             0       1     0\n   additional_ingredients\n   <chr>                 \n 1 fruit                 \n 2 fruit                 \n 3 none                  \n 4 nuts                  \n 5 fruit                 \n 6 fruit                 \n 7 nuts                  \n 8 none                  \n 9 none                  \n10 nuts                  \n11 icing                 \n12 icing                 \n13 fruit                 \n14 none                  \n15 fruit                 \n16 icing                 \n17 none                  \n18 fruit                 \n19 icing                 \n20 icing                 \n```\n:::\n:::\n\n\nFinally, I'm going to split my data into training and test sets, so that you can see how nicely our recipe can be applied to multiple data frames.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(rsample)\nmuffin_cupcake_split <- initial_split(muffin_cupcake_data)\nmuffin_cupcake_train <- training(muffin_cupcake_split)\nmuffin_cupcake_test <- testing(muffin_cupcake_split)\nrm(muffin_cupcake_data)\n```\n:::\n\n\nOur training data is\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmuffin_cupcake_train\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 15 × 10\n   type    flour  milk sugar butter   egg baking_powder vanilla  salt\n   <chr>   <dbl> <dbl> <dbl>  <dbl> <dbl>         <dbl>   <dbl> <dbl>\n 1 Cupcake    42    18    25     NA     5             1       0     0\n 2 Muffin     50    17    17      8     6             1       0     0\n 3 Cupcake    38    15    23     NA     8             0       1     0\n 4 Cupcake    39    13    17     19    10             1       1     0\n 5 Muffin     47    26    10     10     4            NA      NA     0\n 6 Muffin     55    27     3      7     5             2       1     0\n 7 Cupcake    42    21    16     10     8             3       0     0\n 8 Muffin     50    NA    17     11     4             1       0     0\n 9 Muffin     47    23    18      6     4             1       0     0\n10 Cupcake    34    17    23     11    13             0       1     0\n11 Cupcake    39     0    26     19    14             1       1     0\n12 Cupcake    36    14    21     14    11             2       1     0\n13 Muffin     NA    NA    17     17     8            NA       0     0\n14 Muffin     50    25    12      6     5             2       1     0\n15 Cupcake    36    16    24     12     9             1      NA     0\n   additional_ingredients\n   <chr>                 \n 1 icing                 \n 2 none                  \n 3 fruit                 \n 4 none                  \n 5 none                  \n 6 fruit                 \n 7 icing                 \n 8 nuts                  \n 9 none                  \n10 icing                 \n11 icing                 \n12 none                  \n13 nuts                  \n14 fruit                 \n15 icing                 \n```\n:::\n:::\n\n\nand our testing data is\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmuffin_cupcake_test\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 5 × 10\n  type    flour  milk sugar butter   egg baking_powder vanilla  salt\n  <chr>   <dbl> <dbl> <dbl>  <dbl> <dbl>         <dbl>   <dbl> <dbl>\n1 Muffin     55    28     3      7     5             2       0     0\n2 Muffin     47    24    12      6     9             1      NA     0\n3 Muffin     54    27     7      5     5             2       0     0\n4 Cupcake    NA    17    20     20     5             2       1     0\n5 Cupcake    38    15    31      8     6             1       1     0\n  additional_ingredients\n  <chr>                 \n1 fruit                 \n2 fruit                 \n3 nuts                  \n4 fruit                 \n5 fruit                 \n```\n:::\n:::\n\n\n## Writing and applying the recipe\n\nNow that we've set up our data, we're ready to write some recipes and do some baking! The first thing we need to do is get the ingredients. We can use formula notation within the `recipe()` function to do this: the thing we're trying to predict is the variable to the left of the `~`, and the predictor variables are the things to the right of it (Since I'm including all of my variables, I could have written `type ~ .`).\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# define the recipe (it looks a lot like applying the lm function)\nmodel_recipe <- recipe(type ~ flour + milk + sugar + butter + egg + \n                         baking_powder + vanilla + salt + additional_ingredients, \n                       data = muffin_cupcake_train)\n```\n:::\n\n\nIf we print a summary of the `model_recipe` object, it just shows us the variables we've specified, their type, and whether they're a predictor or an outcome.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsummary(model_recipe)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 10 × 4\n   variable               type      role      source  \n   <chr>                  <list>    <chr>     <chr>   \n 1 flour                  <chr [2]> predictor original\n 2 milk                   <chr [2]> predictor original\n 3 sugar                  <chr [2]> predictor original\n 4 butter                 <chr [2]> predictor original\n 5 egg                    <chr [2]> predictor original\n 6 baking_powder          <chr [2]> predictor original\n 7 vanilla                <chr [2]> predictor original\n 8 salt                   <chr [2]> predictor original\n 9 additional_ingredients <chr [3]> predictor original\n10 type                   <chr [3]> outcome   original\n```\n:::\n:::\n\n\n### Writing the recipe steps\n\nSo now we have our ingredients, we are ready to write the recipe (i.e. describe our pre-processing steps). We write the recipe one step at a time. We have many steps to choose from, including:\n\n-   `step_dummy()`: creating dummy variables from categorical variables.\n\n-   `step_zzzimpute()`: where instead of \"`zzz`\" it is the name of a method, such as `step_knnimpute()`, `step_meanimpute()`, `step_modeimpute()`. I find that the fancier imputation methods are reeeeally slow for decently large datasets, so I would probably do this step outside of the recipes package unless you just want to do a quick mean or mode impute (which, to be honest, I often do).\n\n-   `step_scale()`: normalize to have a standard deviation of 1.\n\n-   `step_center()`: center to have a mean of 0.\n\n-   `step_range()`: normalize numeric data to be within a pre-defined range of values.\n\n-   `step_pca()`: create principal component variables from your data.\n\n-   `step_nzv()`: remove variables that have (or almost have) the same value for every data point.\n\nYou can also create your own step (which I've never felt the need to do, but the details of which can be found here https://tidymodels.github.io/recipes/articles/Custom_Steps.html).\n\nIn each step, you need to specify which variables you want to apply it to. There are many ways to do this:\n\n1.  Specifying the variable name(s) as the first argument\n\n2.  Standard dplyr selectors:\n\n    -   `everything()` applies the step to all columns,\n\n    -   `contains()` allows you to specify column names that contain a specific string,\n\n    -   `starts_with()` allows you to specify column names that start with a sepcific string,\n\n    -   etc\n\n3.  Functions that specify the role of the variables:\n\n    -   `all_predictors()` applies the step to the predictor variables only\n\n    -   `all_outcomes()` applies the step to the outcome variable(s) only\n\n4.  Functions that specify the type of the variables:\n\n    -   `all_nominal()` applies the step to all variables that are nominal (categorical)\n\n    -   `all_numeric()` applies the step to all variables that are numeric\n\nTo ignore a specific column, you can specify it's name with a negative sign as a variable (just like you would in `select()`)\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# define the steps we want to apply\nmodel_recipe_steps <- model_recipe %>% \n  # mean impute numeric variables\n  step_impute_mean(all_numeric()) %>%\n  # convert the additional ingredients variable to dummy variables\n  step_dummy(additional_ingredients) %>%\n  # rescale all numeric variables except for vanilla, salt and baking powder to lie between 0 and 1\n  step_range(all_numeric(), min = 0, max = 1, -vanilla, -salt, -baking_powder) %>%\n  # remove predictor variables that are almost the same for every entry\n  step_nzv(all_predictors()) \n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nmodel_recipe_steps\n```\n\n::: {.cell-output .cell-output-stderr}\n```\n\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\n── Recipe ──────────────────────────────────────────────────────────────────────\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\n\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\n── Inputs \n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nNumber of variables by role\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\noutcome:   1\npredictor: 9\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\n\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\n── Operations \n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\n• Mean imputation for: all_numeric()\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\n• Dummy variables from: additional_ingredients\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\n• Range scaling to [0,1] for: all_numeric(), -vanilla, -salt, -baking_powder\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\n• Sparse, unbalanced variable filter on: all_predictors()\n```\n:::\n:::\n\n\nNote that the order in which you apply the steps does matter to some extent. The recommended ordering ([taken from here](https://tidymodels.github.io/recipes/articles/Ordering.html)) is\n\n1.  Impute\n\n2.  Individual transformations for skewness and other issues\n\n3.  Discretize (if needed and if you have no other choice)\n\n4.  Create dummy variables\n\n5.  Create interactions\n\n6.  Normalization steps (center, scale, range, etc)\n\n7.  Multivariate transformation (e.g. PCA, spatial sign, etc)\n\n### Preparing the recipe\n\nNext, we need to provide a dataset on which to base the pre-processing steps. This allows the same recipe to be applied to multiple datasets.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nprepped_recipe <- prep(model_recipe_steps, training = muffin_cupcake_train)\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nprepped_recipe\n```\n\n::: {.cell-output .cell-output-stderr}\n```\n\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\n── Recipe ──────────────────────────────────────────────────────────────────────\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\n\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\n── Inputs \n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nNumber of variables by role\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\noutcome:   1\npredictor: 9\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\n\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\n── Training information \n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nTraining data contained 15 data points and 6 incomplete rows.\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\n\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\n── Operations \n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\n• Mean imputation for: flour, milk, sugar, butter, egg, ... | Trained\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\n• Dummy variables from: additional_ingredients | Trained\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\n• Range scaling to [0,1] for: flour, milk, sugar, butter, egg, ... | Trained\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\n• Sparse, unbalanced variable filter removed: salt | Trained\n```\n:::\n:::\n\n\n### Bake the recipe\n\nNext, you apply your recipe to your datasets.\n\nSo what did our recipe do?\n\n-   `step_meanimpute(all_numeric())` imputed all of the missing values with the mean value for that variable\n\n-   `step_dummy(additional_ingredients)` converted the `additional_ingredients` into three dummy variables corresponding to three of the four levels of the original variable\n\n-   `step_range(all_numeric(), min = 0, max = 1, -vanilla, -salt, -baking_powder)` converted the range of all of the numeric variables except for those specified to lie between 0 and 1\n\n-   `step_nzv(all_predictors())` removed the `salt` variable since it was 0 across all rows (except where it was missing)\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmuffin_cupcake_train_preprocessed <- bake(prepped_recipe, muffin_cupcake_train) \nmuffin_cupcake_train_preprocessed\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 15 × 11\n    flour  milk sugar butter   egg baking_powder vanilla type   \n    <dbl> <dbl> <dbl>  <dbl> <dbl>         <dbl>   <dbl> <fct>  \n 1 0.381  0.667 0.957 0.426    0.1          1      0     Cupcake\n 2 0.762  0.630 0.609 0.154    0.2          1      0     Muffin \n 3 0.190  0.556 0.870 0.426    0.4          0      1     Cupcake\n 4 0.238  0.481 0.609 1        0.6          1      1     Cupcake\n 5 0.619  0.963 0.304 0.308    0            1.23   0.538 Muffin \n 6 1      1     0     0.0769   0.1          2      1     Muffin \n 7 0.381  0.778 0.565 0.308    0.4          3      0     Cupcake\n 8 0.762  0.661 0.609 0.385    0            1      0     Muffin \n 9 0.619  0.852 0.652 0        0            1      0     Muffin \n10 0      0.630 0.870 0.385    0.9          0      1     Cupcake\n11 0.238  0     1     1        1            1      1     Cupcake\n12 0.0952 0.519 0.783 0.615    0.7          2      1     Cupcake\n13 0.439  0.661 0.609 0.846    0.4          1.23   0     Muffin \n14 0.762  0.926 0.391 0        0.1          2      1     Muffin \n15 0.0952 0.593 0.913 0.462    0.5          1      0.538 Cupcake\n   additional_ingredients_icing additional_ingredients_none\n                          <dbl>                       <dbl>\n 1                            1                           0\n 2                            0                           1\n 3                            0                           0\n 4                            0                           1\n 5                            0                           1\n 6                            0                           0\n 7                            1                           0\n 8                            0                           0\n 9                            0                           1\n10                            1                           0\n11                            1                           0\n12                            0                           1\n13                            0                           0\n14                            0                           0\n15                            1                           0\n   additional_ingredients_nuts\n                         <dbl>\n 1                           0\n 2                           0\n 3                           0\n 4                           0\n 5                           0\n 6                           0\n 7                           0\n 8                           1\n 9                           0\n10                           0\n11                           0\n12                           0\n13                           1\n14                           0\n15                           0\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nmuffin_cupcake_test_preprocessed <- bake(prepped_recipe, muffin_cupcake_test)\nmuffin_cupcake_test_preprocessed\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 5 × 11\n  flour  milk sugar butter   egg baking_powder vanilla type   \n  <dbl> <dbl> <dbl>  <dbl> <dbl>         <dbl>   <dbl> <fct>  \n1 1     1     0     0.0769   0.1             2   0     Muffin \n2 0.619 0.889 0.391 0        0.5             1   0.538 Muffin \n3 0.952 1     0.174 0        0.1             2   0     Muffin \n4 0.439 0.630 0.739 1        0.1             2   1     Cupcake\n5 0.190 0.556 1     0.154    0.2             1   1     Cupcake\n  additional_ingredients_icing additional_ingredients_none\n                         <dbl>                       <dbl>\n1                            0                           0\n2                            0                           0\n3                            0                           0\n4                            0                           0\n5                            0                           0\n  additional_ingredients_nuts\n                        <dbl>\n1                           0\n2                           0\n3                           1\n4                           0\n5                           0\n```\n:::\n:::\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}